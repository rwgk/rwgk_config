# WSL Windows Helper Pack generated by ChatGPT

# Assumes: export WHOME=... (WSL path to Windows home) is set in ~/.profile

# --- helpers ---------------------------------------------------------------

_require_wslpath() {
    if ! command -v wslpath >/dev/null 2>&1; then
        echo "Error: wslpath not found (are you in WSL?)." >&2
        return 1
    fi
}

# Convert a possibly-Windows path to WSL path.
# If it looks like a Windows path (has backslashes or a drive letter), use wslpath.
# Otherwise pass it through unchanged (treated as a WSL path).
_to_wsl_path() {
    _require_wslpath || return 1
    local in="$1"
    if [[ "$in" =~ ^[A-Za-z]:[\\/]|\\\\ ]]; then
        wslpath "$in"
    else
        printf '%s\n' "$in"
    fi
}

# --- commands --------------------------------------------------------------

# pwdwin — print current dir as Windows path (for pasting into Windows apps)
pwdwin() {
    _require_wslpath || return 1
    wslpath -w "$PWD"
}

# cdwin — cd into a Windows-style path, or $WHOME if no arg.
# Supports "~\Something" (Windows-style home-relative).
cdwin() {
    _require_wslpath || return 1

    local target wsl_target winhome

    if [[ "$#" -eq 0 ]]; then
        if [[ -n "${WHOME:-}" && -d "$WHOME" ]]; then
            cd "$WHOME" || return
        else
            echo "Error: WHOME is not set or not a directory. Export WHOME in ~/.profile." >&2
            return 1
        fi
        return 0
    fi

    target="$1"

    # Handle Windows-style "~\Subdir" or "~/" relative to Windows home
    if [[ "$target" =~ ^~[\\/] ]]; then
        if [[ -z "${WHOME:-}" ]]; then
            echo "Error: WHOME is not set; cannot expand '~\\' relative path." >&2
            return 1
        fi
        # Build the Windows-style home path from WHOME dynamically
        winhome="$(wslpath -w "$WHOME")" || return 1
        # Strip the leading "~\" or "~/"
        local rest="${target:2}"
        # Compose a Windows path, then convert to WSL
        wsl_target="$(_to_wsl_path "${winhome}\\${rest}")" || return 1
    else
        # If it's Windows-looking, convert; else use as-is
        wsl_target="$(_to_wsl_path "$target")" || return 1
    fi

    if [[ -d "$wsl_target" ]]; then
        cd "$wsl_target" || return
    else
        echo "Error: Not a directory: $wsl_target" >&2
        return 1
    fi
}

# explorerwin — open Windows Explorer at current directory (or given path)
explorerwin() (
    _require_wslpath || exit 1

    local target exe
    if [ "$#" -eq 0 ]; then
        target="$PWD"
    elif [ "$#" -eq 1 ]; then
        target="$1"
    else
        echo "Usage: explorerwin [path]" >&2
        exit 1
    fi

    exe=/mnt/c/Windows/explorer.exe
    if [ ! -x "$exe" ]; then
        echo "Error: $exe not found or not executable." >&2
        exit 1
    fi

    # Convert to Windows path only at the call site
    exec nohup "$exe" "$(wslpath -w "$target")" >/dev/null 2>&1
)
