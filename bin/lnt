#!/bin/bash

# Starts COMMAND in background with stdout & stderr sent to LOG, tail -f LOG.
#
# LOG is created in $L, with timestamped filename.
# tail command automatically terminates shortly after COMMAND terminates.
#
# Ctrl-C will only interrupt the tail command; COMMAND will keep running in
# background.

set -euo pipefail

if [ $# -lt 1 ]; then
    echo "log-n-tail usage: $0 COMMAND [ ARGS ]" >&2
    exit 1
fi

if [ -z "${L:-}" ]; then
    echo 'FATAL: $L is not defined' >&2
    exit 1
fi

# Ensure log directory exists
if [ ! -d "$L" ]; then
    echo "FATAL: Log directory '$L' does not exist" >&2
    exit 1
fi

LOG="$L/$(basename "$1")_log_$(date "+%Y-%m-%d+%H%M%S").txt"

# Check if log file already exists (unlikely but possible)
if [ -e "$LOG" ]; then
    echo "FATAL: $LOG already exists" >&2
    exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WRAPPER="$SCRIPT_DIR/show_pid_and_exec.sh"

# Start command using wrapper (wrapper writes PID then exec's the command)
set -m # To run background job in a separate process group, protecting it from Ctrl-C.
"$WRAPPER" "$@" >&"$LOG" &
CMDPID="$!"
sleep 0.5
set -x
tail -f --pid="$CMDPID" "$LOG"
